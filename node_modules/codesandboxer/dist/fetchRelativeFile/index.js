'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

// Imports that are not named may be .js, .json, or /index.js. Node resolves them
// in that order.
var fetchProbablyJS = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(url, path, pkg, importReplacements, config) {
    var extensions, extension, data;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            extensions = config.extensions || [];
            // We add in the .js and .json extensions as the default accepted extensions

            extensions = ['.js', '.json'].concat((0, _toConsumableArray3.default)(extensions));
            extensions = [].concat((0, _toConsumableArray3.default)(extensions), (0, _toConsumableArray3.default)(extensions.map(function (extension) {
              return '/index' + extension;
            })));

          case 3:
            if (!extensions.length) {
              _context.next = 12;
              break;
            }

            extension = extensions.shift();
            _context.next = 7;
            return attemptToFetch(url, path, pkg, importReplacements, extension);

          case 7:
            data = _context.sent;

            if (!data) {
              _context.next = 10;
              break;
            }

            return _context.abrupt('return', data);

          case 10:
            _context.next = 3;
            break;

          case 12:
            throw new Error('file not found at: ' + url + '; tried extensions: ' + extensions.join(', '));

          case 13:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function fetchProbablyJS(_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
}();

var _parseFile = require('../parseFile');

var _replaceImports = require('../replaceImports');

var _replaceImports2 = _interopRequireDefault(_replaceImports);

var _absolutesToRelative = require('../utils/absolutesToRelative');

var _absolutesToRelative2 = _interopRequireDefault(_absolutesToRelative);

var _getUrl2 = require('./getUrl');

var _getUrl3 = _interopRequireDefault(_getUrl2);

require('isomorphic-unfetch');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fetchRequest = function fetchRequest(url) {
  return fetch(url).then(function (res) {
    if (res.status === 404) {
      throw new Error('file not found at: ' + url);
    }
    return res.text();
  });
};

/*
This is modified from the canvas answer here:
https://stackoverflow.com/questions/6150289/how-to-convert-image-into-base64-string-using-javascript
*/

function fetchImage(url, path) {
  return new _promise2.default(function (resolve) {
    var img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = url;

    img.onload = function () {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var dataURL;
      canvas.height = this.naturalHeight;
      canvas.width = this.naturalWidth;
      ctx.drawImage(this, 0, 0);
      dataURL = canvas.toDataURL();
      resolve(dataURL);
    };
  }).then(function (file) {
    return { file: file, deps: {}, internalImports: [], path: path };
  });
}

var fetchJS = function fetchJS(url, path, pkg, importReplacements) {
  return fetchRequest(url).then(function (content) {
    return (0, _replaceImports2.default)(content, importReplacements.map(function (m) {
      return [(0, _absolutesToRelative2.default)(path, m[0]), m[1]];
    }));
  })
  // this is not correct
  .then(function (content) {
    return (0, _parseFile.parseFile)(content, pkg);
  }).then(function (file) {
    return (0, _extends3.default)({}, file, { path: path });
  });
};

var fetchSass = function fetchSass(url, path) {
  return fetchRequest(url).then(_parseFile.parseSassFile).then(function (file) {
    return (0, _extends3.default)({}, file, { path: path });
  });
};

var fetchScss = function fetchScss(url, path) {
  return fetchRequest(url).then(_parseFile.parseScssFile).then(function (file) {
    return (0, _extends3.default)({}, file, { path: path });
  });
};

var fetchRaw = function fetchRaw(url, path) {
  return fetch(url).then(function (res) {
    if (res.status === 404) {
      throw new Error('file not found at: ' + url);
    }
    return res.text();
  }).then(function (file) {
    return { file: file, deps: {}, internalImports: [], path: path };
  });
};

/*
resolution order:
A.js
A.json
A.userExtension (in order provided)
A/index.js
A/index.json
A/index.userExtension (in order provided)
*/

var attemptToFetch = function attemptToFetch(url, path, pkg, importReplacements, extension) {
  var newPath = '' + path + extension;
  var newUrl = url.replace(/.js$/, extension);
  if (extension === '.json') {
    return fetchRaw(newUrl, newPath).catch(function (error) {
      if (error.message.includes('file not found at:')) return;else throw error;
    });
  }
  return fetchJS(newUrl, newPath, pkg, importReplacements).catch(function (error) {
    if (error.message.includes('file not found at:')) return;else throw error;
  });
};

var fetchFileContents = function fetchFileContents(url, path, _ref2, config) {
  var fileType = _ref2.fileType,
      pkg = _ref2.pkg,
      importReplacements = _ref2.importReplacements;

  if (config.extensions.includes(fileType) || fileType === '.js') {
    return fetchProbablyJS(url, path, pkg, importReplacements, config);
  }

  switch (fileType) {
    case '.png':
    case '.jpeg':
    case '.jpg':
    case '.gif':
    case '.bmp':
    case '.tiff':
      return fetchImage(url, path);
    case '.json':
    case '.css':
      return fetchRaw(url, path);
    case '.scss':
      return fetchScss(url, path);
    case '.sass':
      return fetchSass(url, path);
    default:
      throw new Error('unparseable filetype: ' + fileType + ' for file ' + path);
  }
};

exports.default = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(path, pkg, importReplacements, gitInfo, config) {
    var _getUrl, url, fileType, file;

    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            config = config || { extensions: [] };
            // The new path is the file name we will provide to codesandbox
            // Get the url from the gitInfo. For JS files, we will need to add the filetype
            // This method needs to determine the filetype, so we return it.
            _getUrl = (0, _getUrl3.default)(path, gitInfo), url = _getUrl.url, fileType = _getUrl.fileType;
            _context2.next = 4;
            return fetchFileContents(url, path, {
              fileType: fileType,
              pkg: pkg,
              importReplacements: importReplacements
            }, config);

          case 4:
            file = _context2.sent;
            return _context2.abrupt('return', file);

          case 6:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  function fetchRelativeFile(_x6, _x7, _x8, _x9, _x10) {
    return _ref3.apply(this, arguments);
  }

  return fetchRelativeFile;
}();