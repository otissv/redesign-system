import 'tslib';
import { createElement, useEffect, Fragment, useMemo, useState, useCallback } from 'react';
import { useConfig } from 'docz';
import getter from 'lodash/get';
import styled, { css } from 'styled-components';
import { a as get } from './chunk.esm.js';
import { c as ActionButton, d as ClipboardAction, b as Editor } from './chunk.esm2.js';
import 'react-feather/dist/icons/check';
import 'react-feather/dist/icons/clipboard';
import rgba from 'polished/lib/color/rgba';
import 'copy-text-to-clipboard';
import { LiveError, LiveProvider, LivePreview } from 'react-live';
import Resizable from 're-resizable';
import Smartphone from 'react-feather/dist/icons/smartphone';
import Tablet from 'react-feather/dist/icons/tablet';
import Monitor from 'react-feather/dist/icons/monitor';
import lighten from 'polished/lib/color/lighten';
import darken from 'polished/lib/color/darken';
import Maximize from 'react-feather/dist/icons/maximize';
import Minimize from 'react-feather/dist/icons/minimize';
import Refresh from 'react-feather/dist/icons/refresh-cw';
import Code from 'react-feather/dist/icons/code';
import hotkeys from 'hotkeys-js';

class Storage {
    constructor(name) {
        this.name = name;
    }
    get() {
        if (window && typeof window !== 'undefined') {
            const item = localStorage.getItem(this.name);
            return typeof item === 'string' ? JSON.parse(item) : null;
        }
    }
    set(value) {
        if (window && typeof window !== 'undefined') {
            localStorage.setItem(this.name, JSON.stringify(value));
        }
    }
    delete() {
        if (window && typeof window !== 'undefined') {
            localStorage.removeItem(this.name);
        }
    }
}

const Wrapper = styled.div `
  position: absolute;
  top: 10px;
  left: 50%;
  margin-bottom: 5px;
  transform: translateX(-50%);
`;
const Buttons = styled.div `
  display: flex;
  background: ${get('colors.background')};
  border: 1px solid ${get('colors.border')};
  border-radius: ${get('radii')};
  padding: 3px 5px;
`;
const ResizeBar = ({ onChangeSize }) => (createElement(Wrapper, null,
    createElement(Buttons, null,
        createElement(ActionButton, { onClick: () => onChangeSize('360px', '640px'), title: "Smartphone" },
            createElement(Smartphone, { width: 20 })),
        createElement(ActionButton, { onClick: () => onChangeSize('768px', '1024px'), title: "Tablet" },
            createElement(Tablet, { width: 20 })),
        createElement(ActionButton, { onClick: () => onChangeSize('1366px', '1024px'), title: "Monitor" },
            createElement(Monitor, { width: 20 })))));

const CodeSandboxLogo = props => (createElement("svg", Object.assign({}, props, { viewBox: "0 0 512 512" }),
    createElement("path", { d: "M69.2898098,165.083974 L69.2898098,276.649443 L152.161311,324.692718 L152.161311,412.603224 L241.327633,463.829131 L241.327633,264.06328 L69.2898098,165.083974 Z M89.0172642,137.098529 L260.121958,235.540974 L427.640018,138.456525 L339.210941,87.2017661 L262.258901,131.853758 L179.736828,84.2839889 L89.0172642,137.098529 Z M272.206216,463.739666 L370.845646,406.905256 L370.845646,322.809124 L444.244039,280.276172 L444.244039,167.397587 L272.206216,266.116045 L272.206216,463.739666 Z M255.633239,512 L34,384.729507 L34,128.977638 L255.644267,0 L477.328236,128.432852 L477.328236,384.321468 L255.633239,512 Z", fill: "currentColor" })));

const borderColor = get('colors.border');
const getActionsBg = (p) => p.theme.docz.mode === 'light'
    ? lighten(0.13, borderColor(p))
    : darken(0.04, borderColor(p));
const Actions = styled.div `
  display: flex;
  justify-content: flex-end;
  padding: 0 5px;
  background: ${getActionsBg};
`;
const actionStyle = css `
  padding: 3px 10px;
  border-left: 1px solid ${borderColor};
`;
const Action = styled(ActionButton) `
  ${actionStyle};
`;
const Clipboard = styled(ClipboardAction) `
  ${actionStyle};
`;
const ActionsBar = ({ showEditor, code, fullscreen, codesandboxUrl, onClickRefresh, onClickFullscreen, onClickEditor, }) => {
    const config = useConfig();
    const hasSandbox = Boolean(config.codeSandbox);
    return (createElement(Actions, { withRadius: showEditor },
        createElement(Action, { onClick: onClickRefresh, title: "Refresh playground" },
            createElement(Refresh, { width: 15 })),
        hasSandbox && (createElement(Action, { as: "a", href: codesandboxUrl, target: "_blank", title: "Open in CodeSandbox" },
            createElement(CodeSandboxLogo, { style: { height: '100%' }, width: 15 }))),
        createElement(Clipboard, { content: code }),
        createElement(Action, { onClick: onClickFullscreen, title: fullscreen ? 'Minimize' : 'Maximize' }, fullscreen ? createElement(Minimize, { width: 15 }) : createElement(Maximize, { width: 15 })),
        createElement(Action, { onClick: onClickEditor, title: showEditor ? 'Close editor' : 'Show editor' },
            createElement(Code, { width: 15 }))));
};

const HANDLE_SIZE = '20px';
const borderColor$1 = get('colors.border');
const preBg = get('colors.preBg');
const mode = get('mode');
const getLineBackground = (p) => mode(p) === 'light'
    ? darken(0.05, borderColor$1(p))
    : lighten(0.06, borderColor$1(p));
const line = (position) => (p) => css `
  content: '';
  position: absolute;
  display: block;
  top: ${p.horizontal ? '50%' : position};
  left: ${p.horizontal ? position : '50%'};
  width: ${p.horizontal ? '2px' : '25px'};
  height: ${p.horizontal ? '25px' : '2px'};
  background: ${getLineBackground};
  transform: translate(-50%, -50%);
`;
const whenHorizontal = (on, off) => (p) => p.horizontal ? on : off;
const handleHeight = (p) => p.horizontal ? `calc(100% ${p.full ? '+ 3px' : '- 2px'})` : HANDLE_SIZE;
const Handle = styled.div `
  z-index: ${p => (p.full ? (p.horizontal ? 9999 : 9998) : 9)};
  position: absolute;
  display: block;
  width: ${whenHorizontal(HANDLE_SIZE, 'calc(100% + 3px)')};
  height: ${handleHeight};
  border: 1px solid ${p => lighten(0.03, borderColor$1(p))};
  border-radius: ${whenHorizontal('0 4px 4px 0', '0 0 4px 4px')};
  background: ${p => darken(0.01, preBg(p))};
  box-sizing: content-box;

  ${whenHorizontal(`
      top: 0;
      right: 0;
    `, `
      bottom: 0;
      left: 0;
    `)};

  &:after {
    ${line('calc(50% + 3px)')};
  }

  &:before {
    ${line('calc(50% - 3px)')};
  }
`;

const useHotkeys = (key, cb, inputs) => {
    useEffect(() => {
        hotkeys(key, cb);
        return () => hotkeys.unbind(key);
    }, inputs);
};

const whenFullscreen = (on, off) => (p) => p.full ? on : off;
const Overlay = styled.div `
  top: 0;
  left: 0;
  z-index: ${whenFullscreen(9999, 0)};
  position: ${whenFullscreen('fixed', 'relative')};
  width: ${whenFullscreen('100vw', 'auto')};
  height: ${whenFullscreen('100vh', 'auto')};
  padding: ${whenFullscreen('60px 20px 20px', '0px')};
  margin: ${whenFullscreen('0px', '0 0 30px')};
  background: ${whenFullscreen('rgba(0,0,0,0.5)', 'transparent')};
  box-sizing: border-box;
  transition: background 0.3s;
`;
const borderColor$2 = get('colors.border');
const minusHandleSize = `calc(100% - ${HANDLE_SIZE} + 4px)`;
const Wrapper$1 = styled.div `
  display: flex;
  flex-direction: column;
  height: ${whenFullscreen(minusHandleSize, '100%')};
  width: ${minusHandleSize};
  border: 1px solid ${borderColor$2};
`;
const backgroundColor = get('colors.background');
const PreviewWrapper = styled.div `
  position: relative;
  flex: 1;
  border-bottom: 1px solid ${borderColor$2};
  background: ${backgroundColor};
  min-height: ${whenFullscreen('198px', 'auto')};
`;
const StyledPreviewWrapper = styled.div `
  position: relative;
  box-sizing: border-box;
  width: 100%;
  ${get('styles.playground')};
`;
const StyledError = styled(LiveError) `
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 20px;
  background: ${rgba('black', 0.8)};
  font-size: 16px;
  color: white;
`;
const Pre = styled(Editor) `
  box-sizing: content-box;
  width: calc(100% - 2px);
  border-radius: 0 !important;
  border-bottom: 0;
  border-left: 0;
  margin: 0;
`;
const editorStyle = css `
  border-top: 0;
`;
const fromStorage = (storage) => (key, defaultValue) => {
    const obj = storage.get();
    return obj ? getter(obj, key) : defaultValue;
};
const Playground = ({ position, code: initialCode, codesandbox, className, style, scope, wrapper: CustomWrapper = Fragment, }) => {
    const { themeConfig, native } = useConfig();
    const initialShowEditor = getter(themeConfig, 'showPlaygroundEditor');
    const storage = useMemo(() => new Storage(`doczPlayground-${position}`), []);
    const atPos = fromStorage(storage);
    const initialFullscreen = atPos('fullscreen', false);
    const initialWidth = atPos('width', '100%');
    const initialHeight = atPos('height', '100%');
    const [key, setKey] = useState(0);
    const [code, setCode] = useState(initialCode);
    const [fullscreen, setFullscreen] = useState(() => initialFullscreen);
    const [width, setWidth] = useState(() => initialWidth);
    const [height, setHeight] = useState(() => initialHeight);
    const [showEditor, setShowEditor] = useState(() => Boolean(initialShowEditor));
    const state = {
        fullscreen,
        width,
        height,
        code,
        key,
        showEditor,
    };
    const resizableProps = useMemo(() => ({
        minHeight: fullscreen ? 360 : '100%',
        minWidth: 260,
        maxWidth: '100%',
        maxHeight: '100%',
        size: {
            width,
            height,
        },
        style: {
            margin: '0 auto ',
        },
        enable: {
            top: false,
            right: true,
            bottom: fullscreen,
            left: false,
            topRight: false,
            bottomRight: fullscreen,
            bottomLeft: false,
            topLeft: false,
        },
        handleComponent: {
            right: () => createElement(Handle, { full: fullscreen, horizontal: true }),
            bottom: () => createElement(Handle, { full: fullscreen, horizontal: false }),
        },
        onResizeStop: (e, direction, ref, d) => {
            const width = ref.style.width;
            const height = ref.style.height;
            handleSetSize(width, height);
        },
    }), [fullscreen, width, height]);
    const editorProps = {
        css: editorStyle,
        actions: createElement(Fragment, null),
    };
    const setStorageProp = useCallback((fullscreen) => {
        storage.set(Object.assign({}, state, { fullscreen }));
    }, []);
    const handleToggleFullscreen = () => {
        if (fullscreen)
            storage.delete();
        else
            setStorageProp(true);
        setFullscreen(atPos('fullscreen', false));
        setWidth(atPos('width', '100%'));
        setHeight(atPos('width', '100%'));
    };
    const handleToggleShowEditor = useCallback(() => {
        setShowEditor(s => !s);
    }, []);
    const handleSetSize = useCallback((width, height) => {
        const current = atPos('fullscreen', false);
        setWidth(width);
        setHeight(height);
        setStorageProp(current);
    }, []);
    const handleRefresh = useCallback(() => {
        setKey(key + 1);
    }, []);
    const transformCode = useCallback((code) => {
        if (code.startsWith('()') || code.startsWith('class'))
            return code;
        return `<React.Fragment>${code}</React.Fragment>`;
    }, [code]);
    const codesandboxUrl = useCallback((native) => {
        const url = 'https://codesandbox.io/api/v1/sandboxes/define';
        return `${url}?parameters=${codesandbox}${native ? `&editorsize=75` : ``}`;
    }, [codesandbox, native]);
    const unloadListener = useCallback(() => {
        storage.delete();
    }, []);
    const addUnloadListener = useCallback(() => {
        if (window && typeof window !== 'undefined') {
            window.addEventListener('beforeunload', unloadListener, false);
        }
    }, []);
    const removeUnloadListener = useCallback(() => {
        if (window && typeof window !== 'undefined') {
            window.removeEventListener('beforeunload', unloadListener, false);
        }
    }, []);
    useEffect(() => {
        addUnloadListener();
        return () => removeUnloadListener();
    }, []);
    useEffect(() => {
        if (window && typeof window !== 'undefined') {
            const method = fullscreen ? 'add' : 'remove';
            document.body.classList[method]('with-overlay');
        }
    }, [fullscreen]);
    useHotkeys('esc', () => {
        fullscreen && handleToggleFullscreen();
    });
    return (createElement(LiveProvider, { code: code, scope: scope, transformCode: transformCode, mountStylesheet: false },
        createElement(Overlay, { full: fullscreen },
            fullscreen ? createElement(ResizeBar, { onChangeSize: handleSetSize }) : null,
            createElement(Resizable, Object.assign({}, resizableProps),
                createElement(Wrapper$1, { full: fullscreen },
                    createElement(PreviewWrapper, { full: fullscreen },
                        createElement(StyledPreviewWrapper, null,
                            createElement(CustomWrapper, null,
                                createElement(LivePreview, { className: className, style: style }))),
                        createElement(StyledError, null)),
                    createElement(ActionsBar, Object.assign({}, { fullscreen, showEditor, code }, { codesandboxUrl: codesandboxUrl(native), onClickRefresh: handleRefresh, onClickEditor: handleToggleShowEditor, onClickFullscreen: handleToggleFullscreen })),
                    showEditor && (createElement(Pre, Object.assign({}, editorProps, { onChange: setCode, readOnly: false }), code)))))));
};

export default Playground;
