'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('tslib');
var React = require('react');
var docz = require('docz');
var getter = _interopDefault(require('lodash/get'));
var styled = require('styled-components');
var styled__default = _interopDefault(styled);
var __chunk_1 = require('./chunk.js');
var __chunk_2 = require('./chunk2.js');
require('react-feather/dist/icons/check');
require('react-feather/dist/icons/clipboard');
var rgba = _interopDefault(require('polished/lib/color/rgba'));
require('copy-text-to-clipboard');
var reactLive = require('react-live');
var Resizable = _interopDefault(require('re-resizable'));
var Smartphone = _interopDefault(require('react-feather/dist/icons/smartphone'));
var Tablet = _interopDefault(require('react-feather/dist/icons/tablet'));
var Monitor = _interopDefault(require('react-feather/dist/icons/monitor'));
var lighten = _interopDefault(require('polished/lib/color/lighten'));
var darken = _interopDefault(require('polished/lib/color/darken'));
var Maximize = _interopDefault(require('react-feather/dist/icons/maximize'));
var Minimize = _interopDefault(require('react-feather/dist/icons/minimize'));
var Refresh = _interopDefault(require('react-feather/dist/icons/refresh-cw'));
var Code = _interopDefault(require('react-feather/dist/icons/code'));
var hotkeys = _interopDefault(require('hotkeys-js'));

class Storage {
    constructor(name) {
        this.name = name;
    }
    get() {
        if (window && typeof window !== 'undefined') {
            const item = localStorage.getItem(this.name);
            return typeof item === 'string' ? JSON.parse(item) : null;
        }
    }
    set(value) {
        if (window && typeof window !== 'undefined') {
            localStorage.setItem(this.name, JSON.stringify(value));
        }
    }
    delete() {
        if (window && typeof window !== 'undefined') {
            localStorage.removeItem(this.name);
        }
    }
}

const Wrapper = styled__default.div `
  position: absolute;
  top: 10px;
  left: 50%;
  margin-bottom: 5px;
  transform: translateX(-50%);
`;
const Buttons = styled__default.div `
  display: flex;
  background: ${__chunk_1.get('colors.background')};
  border: 1px solid ${__chunk_1.get('colors.border')};
  border-radius: ${__chunk_1.get('radii')};
  padding: 3px 5px;
`;
const ResizeBar = ({ onChangeSize }) => (React.createElement(Wrapper, null,
    React.createElement(Buttons, null,
        React.createElement(__chunk_2.ActionButton, { onClick: () => onChangeSize('360px', '640px'), title: "Smartphone" },
            React.createElement(Smartphone, { width: 20 })),
        React.createElement(__chunk_2.ActionButton, { onClick: () => onChangeSize('768px', '1024px'), title: "Tablet" },
            React.createElement(Tablet, { width: 20 })),
        React.createElement(__chunk_2.ActionButton, { onClick: () => onChangeSize('1366px', '1024px'), title: "Monitor" },
            React.createElement(Monitor, { width: 20 })))));

const CodeSandboxLogo = props => (React.createElement("svg", Object.assign({}, props, { viewBox: "0 0 512 512" }),
    React.createElement("path", { d: "M69.2898098,165.083974 L69.2898098,276.649443 L152.161311,324.692718 L152.161311,412.603224 L241.327633,463.829131 L241.327633,264.06328 L69.2898098,165.083974 Z M89.0172642,137.098529 L260.121958,235.540974 L427.640018,138.456525 L339.210941,87.2017661 L262.258901,131.853758 L179.736828,84.2839889 L89.0172642,137.098529 Z M272.206216,463.739666 L370.845646,406.905256 L370.845646,322.809124 L444.244039,280.276172 L444.244039,167.397587 L272.206216,266.116045 L272.206216,463.739666 Z M255.633239,512 L34,384.729507 L34,128.977638 L255.644267,0 L477.328236,128.432852 L477.328236,384.321468 L255.633239,512 Z", fill: "currentColor" })));

const borderColor = __chunk_1.get('colors.border');
const getActionsBg = (p) => p.theme.docz.mode === 'light'
    ? lighten(0.13, borderColor(p))
    : darken(0.04, borderColor(p));
const Actions = styled__default.div `
  display: flex;
  justify-content: flex-end;
  padding: 0 5px;
  background: ${getActionsBg};
`;
const actionStyle = styled.css `
  padding: 3px 10px;
  border-left: 1px solid ${borderColor};
`;
const Action = styled__default(__chunk_2.ActionButton) `
  ${actionStyle};
`;
const Clipboard = styled__default(__chunk_2.ClipboardAction) `
  ${actionStyle};
`;
const ActionsBar = ({ showEditor, code, fullscreen, codesandboxUrl, onClickRefresh, onClickFullscreen, onClickEditor, }) => {
    const config = docz.useConfig();
    const hasSandbox = Boolean(config.codeSandbox);
    return (React.createElement(Actions, { withRadius: showEditor },
        React.createElement(Action, { onClick: onClickRefresh, title: "Refresh playground" },
            React.createElement(Refresh, { width: 15 })),
        hasSandbox && (React.createElement(Action, { as: "a", href: codesandboxUrl, target: "_blank", title: "Open in CodeSandbox" },
            React.createElement(CodeSandboxLogo, { style: { height: '100%' }, width: 15 }))),
        React.createElement(Clipboard, { content: code }),
        React.createElement(Action, { onClick: onClickFullscreen, title: fullscreen ? 'Minimize' : 'Maximize' }, fullscreen ? React.createElement(Minimize, { width: 15 }) : React.createElement(Maximize, { width: 15 })),
        React.createElement(Action, { onClick: onClickEditor, title: showEditor ? 'Close editor' : 'Show editor' },
            React.createElement(Code, { width: 15 }))));
};

const HANDLE_SIZE = '20px';
const borderColor$1 = __chunk_1.get('colors.border');
const preBg = __chunk_1.get('colors.preBg');
const mode = __chunk_1.get('mode');
const getLineBackground = (p) => mode(p) === 'light'
    ? darken(0.05, borderColor$1(p))
    : lighten(0.06, borderColor$1(p));
const line = (position) => (p) => styled.css `
  content: '';
  position: absolute;
  display: block;
  top: ${p.horizontal ? '50%' : position};
  left: ${p.horizontal ? position : '50%'};
  width: ${p.horizontal ? '2px' : '25px'};
  height: ${p.horizontal ? '25px' : '2px'};
  background: ${getLineBackground};
  transform: translate(-50%, -50%);
`;
const whenHorizontal = (on, off) => (p) => p.horizontal ? on : off;
const handleHeight = (p) => p.horizontal ? `calc(100% ${p.full ? '+ 3px' : '- 2px'})` : HANDLE_SIZE;
const Handle = styled__default.div `
  z-index: ${p => (p.full ? (p.horizontal ? 9999 : 9998) : 9)};
  position: absolute;
  display: block;
  width: ${whenHorizontal(HANDLE_SIZE, 'calc(100% + 3px)')};
  height: ${handleHeight};
  border: 1px solid ${p => lighten(0.03, borderColor$1(p))};
  border-radius: ${whenHorizontal('0 4px 4px 0', '0 0 4px 4px')};
  background: ${p => darken(0.01, preBg(p))};
  box-sizing: content-box;

  ${whenHorizontal(`
      top: 0;
      right: 0;
    `, `
      bottom: 0;
      left: 0;
    `)};

  &:after {
    ${line('calc(50% + 3px)')};
  }

  &:before {
    ${line('calc(50% - 3px)')};
  }
`;

const useHotkeys = (key, cb, inputs) => {
    React.useEffect(() => {
        hotkeys(key, cb);
        return () => hotkeys.unbind(key);
    }, inputs);
};

const whenFullscreen = (on, off) => (p) => p.full ? on : off;
const Overlay = styled__default.div `
  top: 0;
  left: 0;
  z-index: ${whenFullscreen(9999, 0)};
  position: ${whenFullscreen('fixed', 'relative')};
  width: ${whenFullscreen('100vw', 'auto')};
  height: ${whenFullscreen('100vh', 'auto')};
  padding: ${whenFullscreen('60px 20px 20px', '0px')};
  margin: ${whenFullscreen('0px', '0 0 30px')};
  background: ${whenFullscreen('rgba(0,0,0,0.5)', 'transparent')};
  box-sizing: border-box;
  transition: background 0.3s;
`;
const borderColor$2 = __chunk_1.get('colors.border');
const minusHandleSize = `calc(100% - ${HANDLE_SIZE} + 4px)`;
const Wrapper$1 = styled__default.div `
  display: flex;
  flex-direction: column;
  height: ${whenFullscreen(minusHandleSize, '100%')};
  width: ${minusHandleSize};
  border: 1px solid ${borderColor$2};
`;
const backgroundColor = __chunk_1.get('colors.background');
const PreviewWrapper = styled__default.div `
  position: relative;
  flex: 1;
  border-bottom: 1px solid ${borderColor$2};
  background: ${backgroundColor};
  min-height: ${whenFullscreen('198px', 'auto')};
`;
const StyledPreviewWrapper = styled__default.div `
  position: relative;
  box-sizing: border-box;
  width: 100%;
  ${__chunk_1.get('styles.playground')};
`;
const StyledError = styled__default(reactLive.LiveError) `
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 20px;
  background: ${rgba('black', 0.8)};
  font-size: 16px;
  color: white;
`;
const Pre = styled__default(__chunk_2.Editor) `
  box-sizing: content-box;
  width: calc(100% - 2px);
  border-radius: 0 !important;
  border-bottom: 0;
  border-left: 0;
  margin: 0;
`;
const editorStyle = styled.css `
  border-top: 0;
`;
const fromStorage = (storage) => (key, defaultValue) => {
    const obj = storage.get();
    return obj ? getter(obj, key) : defaultValue;
};
const Playground = ({ position, code: initialCode, codesandbox, className, style, scope, wrapper: CustomWrapper = React.Fragment, }) => {
    const { themeConfig, native } = docz.useConfig();
    const initialShowEditor = getter(themeConfig, 'showPlaygroundEditor');
    const storage = React.useMemo(() => new Storage(`doczPlayground-${position}`), []);
    const atPos = fromStorage(storage);
    const initialFullscreen = atPos('fullscreen', false);
    const initialWidth = atPos('width', '100%');
    const initialHeight = atPos('height', '100%');
    const [key, setKey] = React.useState(0);
    const [code, setCode] = React.useState(initialCode);
    const [fullscreen, setFullscreen] = React.useState(() => initialFullscreen);
    const [width, setWidth] = React.useState(() => initialWidth);
    const [height, setHeight] = React.useState(() => initialHeight);
    const [showEditor, setShowEditor] = React.useState(() => Boolean(initialShowEditor));
    const state = {
        fullscreen,
        width,
        height,
        code,
        key,
        showEditor,
    };
    const resizableProps = React.useMemo(() => ({
        minHeight: fullscreen ? 360 : '100%',
        minWidth: 260,
        maxWidth: '100%',
        maxHeight: '100%',
        size: {
            width,
            height,
        },
        style: {
            margin: '0 auto ',
        },
        enable: {
            top: false,
            right: true,
            bottom: fullscreen,
            left: false,
            topRight: false,
            bottomRight: fullscreen,
            bottomLeft: false,
            topLeft: false,
        },
        handleComponent: {
            right: () => React.createElement(Handle, { full: fullscreen, horizontal: true }),
            bottom: () => React.createElement(Handle, { full: fullscreen, horizontal: false }),
        },
        onResizeStop: (e, direction, ref, d) => {
            const width = ref.style.width;
            const height = ref.style.height;
            handleSetSize(width, height);
        },
    }), [fullscreen, width, height]);
    const editorProps = {
        css: editorStyle,
        actions: React.createElement(React.Fragment, null),
    };
    const setStorageProp = React.useCallback((fullscreen) => {
        storage.set(Object.assign({}, state, { fullscreen }));
    }, []);
    const handleToggleFullscreen = () => {
        if (fullscreen)
            storage.delete();
        else
            setStorageProp(true);
        setFullscreen(atPos('fullscreen', false));
        setWidth(atPos('width', '100%'));
        setHeight(atPos('width', '100%'));
    };
    const handleToggleShowEditor = React.useCallback(() => {
        setShowEditor(s => !s);
    }, []);
    const handleSetSize = React.useCallback((width, height) => {
        const current = atPos('fullscreen', false);
        setWidth(width);
        setHeight(height);
        setStorageProp(current);
    }, []);
    const handleRefresh = React.useCallback(() => {
        setKey(key + 1);
    }, []);
    const transformCode = React.useCallback((code) => {
        if (code.startsWith('()') || code.startsWith('class'))
            return code;
        return `<React.Fragment>${code}</React.Fragment>`;
    }, [code]);
    const codesandboxUrl = React.useCallback((native) => {
        const url = 'https://codesandbox.io/api/v1/sandboxes/define';
        return `${url}?parameters=${codesandbox}${native ? `&editorsize=75` : ``}`;
    }, [codesandbox, native]);
    const unloadListener = React.useCallback(() => {
        storage.delete();
    }, []);
    const addUnloadListener = React.useCallback(() => {
        if (window && typeof window !== 'undefined') {
            window.addEventListener('beforeunload', unloadListener, false);
        }
    }, []);
    const removeUnloadListener = React.useCallback(() => {
        if (window && typeof window !== 'undefined') {
            window.removeEventListener('beforeunload', unloadListener, false);
        }
    }, []);
    React.useEffect(() => {
        addUnloadListener();
        return () => removeUnloadListener();
    }, []);
    React.useEffect(() => {
        if (window && typeof window !== 'undefined') {
            const method = fullscreen ? 'add' : 'remove';
            document.body.classList[method]('with-overlay');
        }
    }, [fullscreen]);
    useHotkeys('esc', () => {
        fullscreen && handleToggleFullscreen();
    });
    return (React.createElement(reactLive.LiveProvider, { code: code, scope: scope, transformCode: transformCode, mountStylesheet: false },
        React.createElement(Overlay, { full: fullscreen },
            fullscreen ? React.createElement(ResizeBar, { onChangeSize: handleSetSize }) : null,
            React.createElement(Resizable, Object.assign({}, resizableProps),
                React.createElement(Wrapper$1, { full: fullscreen },
                    React.createElement(PreviewWrapper, { full: fullscreen },
                        React.createElement(StyledPreviewWrapper, null,
                            React.createElement(CustomWrapper, null,
                                React.createElement(reactLive.LivePreview, { className: className, style: style }))),
                        React.createElement(StyledError, null)),
                    React.createElement(ActionsBar, Object.assign({}, { fullscreen, showEditor, code }, { codesandboxUrl: codesandboxUrl(native), onClickRefresh: handleRefresh, onClickEditor: handleToggleShowEditor, onClickFullscreen: handleToggleFullscreen })),
                    showEditor && (React.createElement(Pre, Object.assign({}, editorProps, { onChange: setCode, readOnly: false }), code)))))));
};

exports.default = Playground;
