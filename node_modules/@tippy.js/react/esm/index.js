import React, { forwardRef, cloneElement, useState, useRef, useLayoutEffect, useEffect, Children } from 'react';
import { createPortal } from 'react-dom';
import PropTypes from 'prop-types';
import tippy from 'tippy.js';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function preserveRef(ref, node) {
  if (ref) {
    if (typeof ref === 'function') {
      ref(node);
    }

    if ({}.hasOwnProperty.call(ref, 'current')) {
      ref.current = node;
    }
  }
}
function ssrSafeCreateDiv() {
  return typeof document !== 'undefined' && document.createElement('div');
}
function updateClassName(tooltip, action, classNames) {
  classNames.split(/\s+/).forEach(function (name) {
    if (name) {
      tooltip.classList[action](name);
    }
  });
}

// on the server. To get around it, we can conditionally
// useEffect on the server (no-op) and useLayoutEffect in the
// browser. We need useLayoutEffect because we want Tippy to
// perform sync mutations to the DOM elements after renders
// to prevent jitters/jumps, especially when updating content.

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof document !== 'undefined' ? useLayoutEffect : useEffect;

function Tippy(_ref) {
  var children = _ref.children,
      content = _ref.content,
      className = _ref.className,
      onCreate = _ref.onCreate,
      isVisible = _ref.isVisible,
      _ref$isEnabled = _ref.isEnabled,
      isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled,
      _ref$ignoreAttributes = _ref.ignoreAttributes,
      ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes,
      _ref$multiple = _ref.multiple,
      multiple = _ref$multiple === void 0 ? true : _ref$multiple,
      restOfNativeProps = _objectWithoutPropertiesLoose(_ref, ["children", "content", "className", "onCreate", "isVisible", "isEnabled", "ignoreAttributes", "multiple"]);

  var _useState = useState(false),
      isMounted = _useState[0],
      setIsMounted = _useState[1];

  var containerRef = useRef(ssrSafeCreateDiv());
  var targetRef = useRef();
  var instanceRef = useRef();
  var isControlledMode = typeof isVisible === 'boolean';

  var options = _extends({
    ignoreAttributes: ignoreAttributes,
    multiple: multiple
  }, restOfNativeProps, {
    content: containerRef.current
  });

  if (isControlledMode) {
    options.trigger = 'manual';
  }

  useIsomorphicLayoutEffect(function () {
    instanceRef.current = tippy(targetRef.current, options);

    if (onCreate) {
      onCreate(instanceRef.current);
    }

    if (!isEnabled) {
      instanceRef.current.disable();
    }

    if (isVisible) {
      instanceRef.current.show();
    }

    setIsMounted(true);
    return function () {
      instanceRef.current.destroy();
      instanceRef.current = null;
    };
  }, []);
  useIsomorphicLayoutEffect(function () {
    if (!isMounted) {
      return;
    }

    instanceRef.current.set(options);

    if (isEnabled) {
      instanceRef.current.enable();
    } else {
      instanceRef.current.disable();
    }

    if (isControlledMode) {
      if (isVisible) {
        instanceRef.current.show();
      } else {
        instanceRef.current.hide();
      }
    }
  });
  useIsomorphicLayoutEffect(function () {
    if (className) {
      var tooltip = instanceRef.current.popperChildren.tooltip;
      updateClassName(tooltip, 'add', className);
      return function () {
        updateClassName(tooltip, 'remove', className);
      };
    }
  }, [className]);
  return React.createElement(React.Fragment, null, cloneElement(children, {
    ref: function ref(node) {
      targetRef.current = node;
      preserveRef(children.ref, node);
    }
  }), isMounted && createPortal(content, containerRef.current));
}

Tippy.propTypes = {
  content: PropTypes.oneOfType([PropTypes.string, PropTypes.element]).isRequired,
  children: PropTypes.element.isRequired,
  onCreate: PropTypes.func,
  isVisible: PropTypes.bool,
  isEnabled: PropTypes.bool,
  className: PropTypes.string
};
var Tippy$1 = forwardRef(function TippyWrapper(_ref2, _ref3) {
  var children = _ref2.children,
      props = _objectWithoutPropertiesLoose(_ref2, ["children"]);

  return React.createElement(Tippy, props, cloneElement(children, {
    ref: function ref(node) {
      preserveRef(_ref3, node);
      preserveRef(children.ref, node);
    }
  }));
});

function TippyGroup(_ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var instancesRef = useRef([]);
  useEffect(function () {
    tippy.group(instancesRef.current, props);
    return function () {
      instancesRef.current = null;
    };
  }, []);
  return Children.map(children, function (child) {
    return cloneElement(child, {
      onCreate: function onCreate(instance) {
        if (child.props.onCreate) {
          child.props.onCreate(instance);
        }

        instancesRef.current.push(instance);
      }
    });
  });
}
TippyGroup.propTypes = {
  children: PropTypes.arrayOf(PropTypes.element).isRequired
};

export default Tippy$1;
export { TippyGroup };
//# sourceMappingURL=index.js.map
